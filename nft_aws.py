#!/usr/bin/python3
#    nft_aws.py
#    Copyright (C) 2020  Pedro Ruiz
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""
Generate files containing nftables sets with AWS IPS
"""

from datetime import datetime
import ipaddress as ip
import requests
import argparse

AWS_URL = "https://ip-ranges.amazonaws.com/ip-ranges.json"

def write_nft_header(file):
    """
    Write the header for nft file
    """
    file.write("# Generated by nft_aws.py on {}\n#\n"
            .format(datetime.now().strftime("%a %b %d %H:%M %Y")))
    file.write("# With the following filters: ")
    if(args.regions is None and args.services is None and args.networkbordergroups is None ):
        file.write("none")
    file.write("\n")

    if args.regions is not None:
        file.write("# \tregions: {}\n".format(args.regions))
    if args.services is not None:
        file.write("# \tservices: {}\n".format(args.services))
    if args.networkbordergroups is not None:
        file.write("# \tnetwork-border-group: {}\n".format(args.networkbordergroups))
    file.write('\n\n\n')


def write_nft_file(file, ipList, ipv6=False):
    """
    Write the list to a nft file
    """
    if(ipv6):
        setname = args.set6name
        type = "ipv6_addr"
    else:
        setname = args.set4name
        type = "ipv4_addr"

    file.seek(0)
    write_nft_header(file)
    file.write('set {} {{\n'
              '\ttype {}\n'
              '\tflags interval, constant\n'
              '\telements = {{\n'.format(setname, type))
    file.write(''.join("\t\t{},\n".format(ip) for ip in ipList))
    file.write('\t}\n')
    file.write('}\n')
    file.truncate()


#ToDo: This function is very slow, must to be optimized
def clean_ip_list(iplist, ipv6=False):
    """
    Remove overlapped networks
    """
    lenIplist = len(iplist)
    forremove = []
    for i, ip1 in enumerate(iplist):
        network1 = ip.ip_network(ip1)
        for j in range(i,lenIplist):
            if i == j:
                continue
            network2 = ip.ip_network(iplist[j])
            if(network1.overlaps(network2)):
                #The small subnet is included on the big subnet
                if(network1.num_addresses > network2.num_addresses):
                    forremove.append(iplist[j])
                else:
                    forremove.append(ip1)


    #Remove the object if exists
    for ips in forremove:
        try:
            iplist.remove(ips)
        except:
            pass


def extract_ip_list(subnets, ipv6=False):
    """
    Obtain the ips from the subnets of aws
    """
    ipList = []
    for subnet in subnets:
        if ipv6:
            ipList.append(subnet['ipv6_prefix'])
        else:
            ipList.append(subnet['ip_prefix'])

    return ipList

def filter_ip_list(subnets):
    """
    Filter all subnets by the filter criteria
    """
    subnetFilter = []
    for subnet in subnets:
        if args.regions is not None:
            passed = False
            for region in args.regions:
                if(region == subnet['region']):
                    passed = True;
                    break;
            if(not passed):
                continue;

        if args.networkbordergroups is not None:
            passed = False
            for networkbordergroup in args.networkbordergroups:
                if(networkbordergroup == subnet['network_border_group']):
                    passed = True;
                    break;
            if(not passed):
                continue;

        if args.services is not None:
            passed = False
            for service in args.services:
                if(service == subnet['service']):
                    passed = True;
                    break;
            if(not passed):
                continue;

        #If the petition is here mean pass the Filter
        subnetFilter.append(subnet)


    return subnetFilter

def create_parser():
    """
    Returns cli argument parser
    """
    parser = argparse.ArgumentParser(description=__doc__,
                                      prog='nft_aws')

    parser.add_argument('-r', '--region',
                        nargs='+',
                        help='Filter by region',
                        required=False,
                        dest="regions")
    parser.add_argument('-g', '--network-border-group',
                        nargs='+',
                        help='Filter by network border group',
                        required=False,
                        dest="networkbordergroups")
    parser.add_argument('-s', '--service',
                        nargs='+',
                        help='Filter by service',
                        required=False,
                        dest="services")
    parser.add_argument('-n', '--set4-name',
                        help='Name for the set ipv4',
                        default="awsip4",
                        required=False,
                        dest="set4name")
    parser.add_argument('-N', '--set6-name',
                        help='Name for the set ipv6',
                        default="awsip6",
                        required=False,
                        dest="set6name")
    parser.add_argument('-o', '--output-ipv4-file',
                        type=argparse.FileType('w'),
                        default="aws-ipv4.nft",
                        help='File where the ipv4 set will be overwritted ',
                        required=False,
                        dest='ipv4file')
    parser.add_argument('-O', '--output-ipv6-file',
                        type=argparse.FileType('w'),
                        default="aws-ipv6.nft",
                        help='File where the ipv4 set will be overwritted ',
                        required=False,
                        dest='ipv6file')
    return parser



if __name__ == "__main__":
    parser = create_parser()
    args = parser.parse_args()

    print("Downloading json from {}".format(AWS_URL))
    r = requests.get(AWS_URL)
    print("------")

    if r.status_code == 200:
        print("Decoding json...")
        jsonAwsIp = r.json()

        print("Filter results...")
        subnetList4 = filter_ip_list(jsonAwsIp['prefixes'])
        subnetList6 = filter_ip_list(jsonAwsIp['ipv6_prefixes'])

        ipList4 = extract_ip_list(subnetList4)
        ipList6 = extract_ip_list(subnetList6, ipv6=True)

        print("Cleaning overlap networks...")
        clean_ip_list(ipList4)
        clean_ip_list(ipList6)

        print("Writting to files...")
        write_nft_file(args.ipv4file, ipList4)
        write_nft_file(args.ipv6file, ipList6, ipv6=True)

        print("------")
        print("\nStats: ipv4: {0}({1}), ipv6: {2}({3})".format(len(ipList4), len(jsonAwsIp['prefixes']), len(ipList6), len(jsonAwsIp['ipv6_prefixes'])))
    else:
        sys.exit("Error downloading AWS IP list")
